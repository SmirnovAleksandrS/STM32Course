 # Потоки и процессы

 У процесса отдельное адресное пр-во. У потока же единое со своим процессом адресное пр-во, но планировщик просто переключает переодически потоки кода (при нескольких ядрах это будет параллелизм, если на одном ядре то это называется Concurrence)

## Атомики

Команда на С++, допустим `a++` не гарантирует что во время ее исполнения не произойдет переключение, т.к. на асме это будет выглядеть примерно так:
```asm
ldr r0, [a]
add r0, 1
sdr r0, [a]
```
Планировщик может прийти в любой момент, и если этот код выполняется одновременно в 2 потоках, то результат будет недетерминирован, т.е если а изначально было 1, то после выполнения там будет или 3 или 2.

Чтобы такого не было (не было гонки) существуют алгоритмы синхронизации, которые заставляют выполнять код строго поочереди, платя за это десятикратно уменьшено скоростью выполнения критической секции.

Атомиком же называется такая функция, которая выполняется строго последовательно и которую нельзя прервать на середине.

Зачастую реализуются в виде отдельных операций, выполняющие простые действия по типу ++ и --.

## Алгоритмы синхронизации

### Семафоры

Структура, в которой лежит числовая переменная и некоторые вспомогательные поля. Она доступна из обоих тасков. Синхронизация происходит за счет того что одна таска ждет пока на семафоре не появится сигнал от второй таски.

```cpp
//Task A
//...
SysCallSemWait(&sem); //ждем на семафоре
//... Ждем ...


//Task B
//...
SysCallSemSignal(&sem) // выставляем сигнал
// Тут уже может выполняться работа в TaskA
```

`SysCallSemWait`, `SysCallSemSignal` и `SysCallSwitchContext` функции которые просто дергают прерывание. В прерывание, передавая туда свой номер, и уже в прерывании, в огромном `switch case` определяется номер и выполняется нужный код. После выполнения `swc` прерывания происходит `bx` переход на `pc`, который сохранился в прерывании.

Обработчик прерываний в одноядерной системе не может быть прерван, т.к. он.... сам и прерывает другие процессы и сам выполняется в привилегированном режиме.

Это просто, но из минусов, если что-то пойдет не так, то код намертво зависнет.

### Запрет прерываний

Тебя не прервут если ты запретил себя прерывать. Очевидно, просто, криво. Если система многоядерная, то мы блокируем прерывания и на других ядрах, ломая процессы там. Если мы выполняемся долго, то много чего пропускаем, если зависаем, то намертво.

### Спин-блокировка

Крутимся в `while` пока выставлен какой-то замок. Просто, очевидно, криво, но не ак костыльно как блокировка прерываний. Жрет ресурсы попусту, т.к. пока нас не сняли с выполнения мы по сути просто крутимся в бесконечном цикле.

### Mutex

Создает семафор и при блокировке честно выключает задачу из планирования, если жде задачу активировали, то возвращает ее в планирование. На каждом цикле, если внутренний счетчки равен 0 (никто не занял mutex) то мы входим syscall и не делаем ничего полезного.

Хороший метод, не жрет ресурсы понапрасну и работает эффективно. Но много системных вызовов, что все таки тяжело.

Но есть лучше - futex.
 
Ровно то же самое, но использует атомики и спинлок, если mutex не блокирован, то просто крутимся в спинлоке, если заблокирован то честно делаем syscall.